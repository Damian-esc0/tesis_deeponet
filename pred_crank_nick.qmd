---
title: Predicciones del método numérico
lang: es
execute: 
  freeze: auto
---

```{julia}
#| output: false
using DifferentialEquations, LinearAlgebra
using DataFrames, CSV

# --- PARÁMETROS FÍSICOS Y DIMENSIONALES ------------------------------------
ρ, c  = 1050.0, 3639.0                        # densidad, calor específico 
k_eff = 5.0                                   # conductividad
t_f   = 1800.0                                # tiempo final 
L     = 0.05                                  # longitud del dominio
c_b   = 3825.0                                # coef. perfusión
Q     = 0.0                                   # fuente térmica
T_M, T_a = 45.0, 37.0                         # temp máxima, temp ambiente

# --- COEFICIENTES ADIMENSIONALES -------------------------------------------
α = ρ * c / k_eff
a₁ = t_f / (α * L^2)
a₂ = t_f * c_b / (ρ * c)
a₃ = (t_f * Q) / (ρ * c * (T_M - T_a))

# --- MALLA ESPACIAL ---------------------------------------------------------
Nx, Ny = 51, 51
dx, dy = 1.0 / (Nx - 1), 1.0 / (Ny - 1)
x = range(0, 1, length=Nx)
y = range(0, 1, length=Ny)
N = Nx * Ny  # total de puntos

# --- CONDICIÓN INICIAL ------------------------------------------------------
u0 = zeros(N)

# --- SISTEMA DE EDOs DEL PDE ------------------------------------------------
function f!(du, u, _, τ)
    U = reshape(u, Nx, Ny)
    D = similar(U)
    @inbounds for i in 1:Nx, j in 1:Ny
        # Derivadas segunda en x
        d2x = if i == 1
            (U[2, j] - 0) / dx^2
        elseif i == Nx
            U_ghost = U[Nx, j] + τ * dx
            (U_ghost - 2U[Nx, j] + U[Nx-1, j]) / dx^2
        else
            (U[i+1, j] - 2U[i, j] + U[i-1, j]) / dx^2
        end

        # Derivadas segunda en y
        d2y = if j == 1
            (U[i, 2] - U[i, 1]) / dy^2
        elseif j == Ny
            (U[i, Ny-1] - U[i, Ny]) / dy^2
        else
            (U[i, j+1] - 2U[i, j] + U[i, j-1]) / dy^2
        end

        D[i, j] = (d2x + d2y - a₂ * U[i, j] + a₃) / a₁
    end
    du .= vec(D)
end

# --- RESOLVER PDE ---------------------------------------------------------
τspan = (0.0, 1.0)
prob = ODEProblem(f!, u0, τspan)
taus = [0.0, 0.25, 0.5, 0.75, 1.0]
sol = solve(prob, Trapezoid(), dt=8e-4, saveat=taus)

# --- PROCESAR SOLUCIÓN EN GRILLA REDUCIDA ---------------------------------
idxs = 1:2:Nx  # índices para submuestreo
npts = length(idxs)^2 * length(taus)

# Preasignar vectores para crear el DataFrame
times = Float64[]
Xs = Float64[]
Ys = Float64[]
Thetas = Float64[]

for (k, τ) in enumerate(taus)
    Θ = reshape(sol(τ), Nx, Ny)
    for j in idxs, i in idxs
        push!(times, τ)
        push!(Xs, x[i])
        push!(Ys, y[j])
        push!(Thetas, Θ[i, j])
    end
end

df = DataFrame(time=times, X=Xs, Y=Ys, Theta=Thetas)

# --- GUARDAR CSV ------------------------------------------------------------
ruta = "data"
CSV.write(joinpath(ruta, "crank_nick.csv"), df)
```

```{julia}
#| label: fig-met-crank-nick
#| fig-cap: "Resultados obtenidos mediante el método numérico de Crank Nickolson."
using DataFrames, CSV, Plots, Statistics
pyplot()

# --- OBTENER VALORES ÚNICOS Y ORDENADOS DE X, Y, TIME ----------------------
x_vals = sort(unique(df.X))
y_vals = sort(unique(df.Y))
times = sort(unique(df.time))  # tiempos

Nx, Ny = length(x_vals), length(y_vals)

# --- RECONSTRUIR MATRICES 2D DE THETA PARA CADA TIEMPO ---------------------
solutions = []

for t in times
    dft = filter(:time => ==(t), df)

    # Crear matriz vacía
    Θ = fill(NaN, Nx, Ny)

    # Llenar la matriz con los valores correspondientes
    for row in eachrow(dft)
        ix = findfirst(==(row.X), x_vals)
        iy = findfirst(==(row.Y), y_vals)
        Θ[ix, iy] = row.Theta
    end

    push!(solutions, Θ)
end

# --- DETERMINAR ESCALA GLOBAL DE COLORES -----------------------------------
zmin = minimum([minimum(u) for u in solutions])
zmax = maximum([maximum(u) for u in solutions])

# --- GRAFICAR EN LAYOUT 3x2 ------------------------------------------------
p = plot(layout = (3, 2), size = (800, 900))

for (i, (t, Θ)) in enumerate(zip(times, solutions))
    surface!(
        p, y_vals, x_vals, Θ;  # transpuesta para que coincidan con x, y
        camera = (45,30),
        xlabel = "Y",
        ylabel = "X",
        zlabel = "T   ",
        title = "t = $(t)",
        subplot = i,
        c = :thermal,
        clim = (zmin, zmax),
        legend = false
    )
end

# Eliminar ejes y contenido del subplot 6
plot!(p[6], framestyle = :none, grid = false, xticks = false, yticks = false)
close("all")

display(p)
```


