{
  "hash": "1c2b7072e805b0d40bd05159e4f9330f",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Predicciones del método numérico\nlang: es\nexecute: \n  freeze: auto\n---\n\n::: {style=\"text-align: justify\"}\nPara validar los resultados del modelo propuesto, se implementó el método de Crank-Nicolson en Julia utilizando la librería *DifferentialEquations.jl*. El método se resolvió sobre una malla refinada de 51×51 puntos para garantizar alta precisión en la solución numérica, calculando las predicciones en los tiempos clave: t = [0.0, 0.25, 0.50, 0.75, 1.0]. En la @fig-met-crank-nick se muestran las cinco gráficas generadas, las cuales ilustran la evolución temporal de la solución en el dominio de estudio.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing DifferentialEquations, LinearAlgebra\nusing DataFrames, CSV\n\n# --- PARÁMETROS FÍSICOS Y DIMENSIONALES ------------------------------------\nρ, c  = 1050.0, 3639.0                        # densidad, calor específico \nk_eff = 5.0                                   # conductividad\nt_f   = 1800.0                                # tiempo final \nL     = 0.05                                  # longitud del dominio\nc_b   = 3825.0                                # coef. perfusión\nQ     = 0.0                                   # fuente térmica\nT_M, T_a = 45.0, 37.0                         # temp máxima, temp ambiente\n\n# --- COEFICIENTES ADIMENSIONALES -------------------------------------------\nα = ρ * c / k_eff\na₁ = t_f / (α * L^2)\na₂ = t_f * c_b / (ρ * c)\na₃ = (t_f * Q) / (ρ * c * (T_M - T_a))\n\n# --- MALLA ESPACIAL --------------------------------------------------------\nNx, Ny = 51, 51\ndx, dy = 1.0 / (Nx - 1), 1.0 / (Ny - 1)\nx = range(0, 1, length=Nx)\ny = range(0, 1, length=Ny)\nN = Nx * Ny  # total de puntos\n\n# --- CONDICIÓN INICIAL ----------------------------------------------------\nu0 = zeros(N)\n\n# --- SISTEMA DE EDOs DEL PDE ----------------------------------------------\nfunction f!(du, u, _, τ)\n    U = reshape(u, Nx, Ny)\n    D = similar(U)\n    @inbounds for i in 1:Nx, j in 1:Ny\n        # Derivadas segunda en x\n        d2x = if i == 1\n            (U[2, j] - 0) / dx^2\n        elseif i == Nx\n            U_ghost = U[Nx, j] + τ * dx\n            (U_ghost - 2U[Nx, j] + U[Nx-1, j]) / dx^2\n        else\n            (U[i+1, j] - 2U[i, j] + U[i-1, j]) / dx^2\n        end\n\n        # Derivadas segunda en y\n        d2y = if j == 1\n            (U[i, 2] - U[i, 1]) / dy^2\n        elseif j == Ny\n            (U[i, Ny-1] - U[i, Ny]) / dy^2\n        else\n            (U[i, j+1] - 2U[i, j] + U[i, j-1]) / dy^2\n        end\n\n        D[i, j] = (d2x + d2y - a₂ * U[i, j] + a₃) / a₁\n    end\n    du .= vec(D)\nend\n\n# --- RESOLVER PDE -------------------------------------------------------\nτspan = (0.0, 1.0)\nprob = ODEProblem(f!, u0, τspan)\ntaus = [0.0, 0.25, 0.5, 0.75, 1.0]\nsol = solve(prob, Trapezoid(), dt=8e-4, saveat=taus)\n\n# --- PROCESAR SOLUCIÓN EN GRILLA REDUCIDA -------------------------------\nidxs = 1:2:Nx  # índices para submuestreo\nnpts = length(idxs)^2 * length(taus)\n\n# Preasignar vectores para crear el DataFrame\ntimes = Float64[]\nXs = Float64[]\nYs = Float64[]\nThetas = Float64[]\n\nfor (k, τ) in enumerate(taus)\n    Θ = reshape(sol(τ), Nx, Ny)\n    for j in idxs, i in idxs\n        push!(times, τ)\n        push!(Xs, x[i])\n        push!(Ys, y[j])\n        push!(Thetas, Θ[i, j])\n    end\nend\n\ndf = DataFrame(time=times, X=Xs, Y=Ys, Theta=Thetas)\n\n# --- GUARDAR CSV ----------------------------------------------------------\nruta = \"data\"\nCSV.write(joinpath(ruta, \"crank_nick.csv\"), df)\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nusing DataFrames, CSV, Plots, Statistics\npyplot()\n\n# --- OBTENER VALORES ÚNICOS Y ORDENADOS DE X, Y, TIME ----------------------\nx_vals = sort(unique(df.X))\ny_vals = sort(unique(df.Y))\ntimes = sort(unique(df.time))  # tiempos\n\nNx, Ny = length(x_vals), length(y_vals)\n\n# --- RECONSTRUIR MATRICES 2D DE THETA PARA CADA TIEMPO ---------------------\nsolutions = []\n\nfor t in times\n    dft = filter(:time => ==(t), df)\n\n    # Crear matriz vacía\n    Θ = fill(NaN, Nx, Ny)\n\n    # Llenar la matriz con los valores correspondientes\n    for row in eachrow(dft)\n        ix = findfirst(==(row.X), x_vals)\n        iy = findfirst(==(row.Y), y_vals)\n        Θ[ix, iy] = row.Theta\n    end\n\n    push!(solutions, Θ)\nend\n\n# --- DETERMINAR ESCALA GLOBAL DE COLORES ---------------------------------\nzmin = minimum([minimum(u) for u in solutions])\nzmax = maximum([maximum(u) for u in solutions])\n\n# --- GRAFICAR EN LAYOUT 3x2 ----------------------------------------------\np = plot(layout = (3, 2), size = (800, 900))\n\nfor (i, (t, Θ)) in enumerate(zip(times, solutions))\n    surface!(\n        p, y_vals, x_vals, Θ;\n        camera = (45,30),\n        xlabel = \"Y\",\n        ylabel = \"X\",\n        zlabel = \"T   \",\n        title = \"t = $(t)\",\n        subplot = i,\n        c = :thermal,\n        clim = (zmin, zmax),\n        legend = false\n    )\nend\n\n# Eliminar ejes y contenido del subplot 6\nplot!(p[6], framestyle = :none,\n            grid = false,\n            xticks = false,\n            yticks = false)\nclose(\"all\")\n\ndisplay(p)\n```\n\n::: {.cell-output .cell-output-display}\n![Resultados obtenidos mediante el método numérico de Crank Nickolson.](pred_crank_nick_files/figure-pdf/fig-met-crank-nick-output-1.svg){#fig-met-crank-nick fig-pos='H'}\n:::\n:::\n\n\n## Guardado de datos\nCon el objetivo de optimizar el proceso de comparación cuantitativa con el modelo de redes neuronales, se exportó un subconjunto representativo de los resultados. Aunque la simulación original utilizó una malla de 51×51 puntos, se almacenaron únicamente los valores correspondientes a una grilla de 26×26 puntos. Esta decisión se basó en:\n\n1. Suficiencia estadística: La densidad de puntos conserva los patrones espaciales críticos.\n2. Eficiencia computacional: Reduce el tamaño del archivo sin perder información relevante.\n\nLos datos se guardaron en un archivo CSV estructurado con las siguientes columnas:\n\n- Coordenadas espacio-temporales (t, x, y) para cada punto de la grilla 26×26.\n- Valores de la solución en los tiempos de interés.\n\nEste archivo permitió calcular de manera estandarizada las métricas de error (MAE, MaxAE, error L2) en la sección de comparación de resultados.\n:::\n\n",
    "supporting": [
      "pred_crank_nick_files/figure-pdf"
    ],
    "filters": []
  }
}