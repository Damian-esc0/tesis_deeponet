{
  "hash": "d9497d6a96d51f11b29a39bf26b8bbe7",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Aplicacion de Crank Nikolson\nlang: es\nexecute: \n  freeze: auto\n---\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing DifferentialEquations, LinearAlgebra, Plots\n\n# Physical parameters\np, c, keff = 1050.0, 3639.0, 5.0\ntf, L0       = 1800.0, 0.05\ncb, Q        = 3825.0, 0.0\nTM, Ta       = 45.0,   37.0\n\n# Dimensionless coefficients\nalpha = p * c / keff\na1 = tf / (alpha * L0^2)\na2 = tf * cb / (p * c)\na3 = (tf * Q) / (p * c * (TM - Ta))\n\n# Spatial grid\nNx, Ny = 50, 50\ndx, dy = 1.0/(Nx-1), 1.0/(Ny-1)\nN = Nx * Ny\n\n# Initial condition\nu0 = zeros(N)\n\n# PDE system\nfunction f!(du, u, p, τ)\n    U = reshape(u, Nx, Ny)\n    D = similar(U)\n    @inbounds for i in 1:Nx, j in 1:Ny\n        # X direction\n        if i == 1\n            d2x = (U[2,j] - 0) / dx^2\n        elseif i == Nx\n            u_ghost = U[Nx,j] + τ * dx\n            d2x = (u_ghost - 2U[Nx,j] + U[Nx-1,j]) / dx^2\n        else\n            d2x = (U[i+1,j] - 2U[i,j] + U[i-1,j]) / dx^2\n        end\n\n        # Y direction\n        if j == 1\n            d2y = (U[i,2] - U[i,1]) / dy^2\n        elseif j == Ny\n            d2y = (U[i,Ny-1] - U[i,Ny]) / dy^2\n        else\n            d2y = (U[i,j+1] - 2U[i,j] + U[i,j-1]) / dy^2\n        end\n\n        D[i,j] = (d2x + d2y - a2*U[i,j] + a3) / a1\n    end\n    du .= vec(D)\nend\n\n# Solve the PDE\nτspan = (0.0, 1.0)\nprob = ODEProblem(f!, u0, τspan)\ntaus = [0.0, 0.25, 0.5, 0.75, 1.0]\nsol = solve(prob, TRBDF2(), dt=5e-4, saveat=taus)\n\n# Crear grilla espacial\nx = range(0, L0, length=Nx)\ny = range(0, L0, length=Ny)\n\n# Obtener la solución en cada τ como matriz 2D\nsolutions = [reshape(sol(τ), Nx, Ny) for τ in taus]\n\n# Calcular mínimo y máximo global para unificar escala de colores (z)\nzmins = [minimum(u) for u in solutions]\nzmaxs = [maximum(u) for u in solutions]\nzmin = minimum(zmins)\nzmax = maximum(zmaxs)\n\n# Crear figura con layout 2x3\np = plot(layout = (2, 3), size = (900, 600))\n\n# Añadir cada superficie a la figura\nfor (i, (τ, uτ)) in enumerate(zip(taus, solutions))\n    surface!(\n        p, x, y, uτ';  # uτ' para que las dimensiones correspondan a (x, y)\n        xlabel = \"x (m)\",\n        ylabel = \"y (m)\",\n        zlabel = \"θ\",\n        title = \"τ = $(τ)\",\n        subplot = i,\n        c = :thermal,\n        clim = (zmin, zmax),  # unifica rango de colores\n        legend = false\n    )\nend\n```\n:::\n\n\n::: {.content-visible when-format=\"html\"}\n\n::: {.cell execution_count=2}\n\n::: {.cell-output .cell-output-display}\n![Resultados obtenidos mediante el método numérico.](metodo-num_files/figure-pdf/fig-crank-nick-output-1.svg){#fig-crank-nick}\n:::\n:::\n\n\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n\n\n![Resultados obtenidos mediante el método numérico.](/metodo-num_files/figure-pdf/fig-crank-nick-output-2.png){#fig-met-num fig-align=\"center\"}\n:::\n\n",
    "supporting": [
      "metodo-num_files/figure-pdf"
    ],
    "filters": []
  }
}