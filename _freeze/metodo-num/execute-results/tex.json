{
  "hash": "31937194aef5abaaca2c3fc3ff1fe42f",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Aplicacion de Crank Nikolson\nlang: es\nexecute: \n  freeze: auto\n---\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing DifferentialEquations, LinearAlgebra\nusing DataFrames, CSV\n\n# --- PARÁMETROS FÍSICOS Y DIMENSIONALES ------------------------------------\nρ, c = 1050.0, 3639.0                         # densidad, calor específico \nk_eff = 5.0                                   # conductividad\nt_f, L = 1800.0, 0.05                         # tiempo final, longitud del dominio\nc_b, Q = 3825.0, 0.0                          # coef. perfusión, fuente térmica\nT_M, T_a = 45.0, 37.0                         # temperatura máxima, ambiente\n\n# --- COEFICIENTES ADIMENSIONALES -------------------------------------------\nα = ρ * c / k_eff\na₁ = t_f / (α * L^2)\na₂ = t_f * c_b / (ρ * c)\na₃ = (t_f * Q) / (ρ * c * (T_M - T_a))\n\n# --- MALLA ESPACIAL ---------------------------------------------------------\nNx, Ny = 51, 51\ndx, dy = 1.0 / (Nx - 1), 1.0 / (Ny - 1)\nx = range(0, 1, length=Nx)\ny = range(0, 1, length=Ny)\nN = Nx * Ny  # total de puntos\n\n# --- CONDICIÓN INICIAL ------------------------------------------------------\nu0 = zeros(N)\n\n# --- SISTEMA DE EDOs DEL PDE ------------------------------------------------\nfunction f!(du, u, _, τ)\n    U = reshape(u, Nx, Ny)\n    D = similar(U)\n    @inbounds for i in 1:Nx, j in 1:Ny\n        # Derivadas segunda en x\n        d2x = if i == 1\n            (U[2, j] - 0) / dx^2\n        elseif i == Nx\n            U_ghost = U[Nx, j] + τ * dx\n            (U_ghost - 2U[Nx, j] + U[Nx-1, j]) / dx^2\n        else\n            (U[i+1, j] - 2U[i, j] + U[i-1, j]) / dx^2\n        end\n\n        # Derivadas segunda en y\n        d2y = if j == 1\n            (U[i, 2] - U[i, 1]) / dy^2\n        elseif j == Ny\n            (U[i, Ny-1] - U[i, Ny]) / dy^2\n        else\n            (U[i, j+1] - 2U[i, j] + U[i, j-1]) / dy^2\n        end\n\n        D[i, j] = (d2x + d2y - a₂ * U[i, j] + a₃) / a₁\n    end\n    du .= vec(D)\nend\n\n# --- RESOLVER PDE ---------------------------------------------------------\nτspan = (0.0, 1.0)\nprob = ODEProblem(f!, u0, τspan)\ntaus = [0.0, 0.25, 0.5, 0.75, 1.0]\nsol = solve(prob, TRBDF2(), dt=5e-4, saveat=taus)\n\n# --- PROCESAR SOLUCIÓN EN GRILLA REDUCIDA ---------------------------------\nidxs = 1:2:Nx  # índices para submuestreo\nnpts = length(idxs)^2 * length(taus)\n\n# Preasignar vectores para crear el DataFrame\ntimes = Float64[]\nXs = Float64[]\nYs = Float64[]\nThetas = Float64[]\n\nfor (k, τ) in enumerate(taus)\n    Θ = reshape(sol(τ), Nx, Ny)\n    for i in idxs, j in idxs\n        push!(times, τ)\n        push!(Xs, x[i])\n        push!(Ys, y[j])\n        push!(Thetas, Θ[i, j])\n    end\nend\n\ndf = DataFrame(time=times, X=Xs, Y=Ys, Theta=Thetas)\n\n# --- GUARDAR CSV ------------------------------------------------------------\nruta = \"data\"\nCSV.write(joinpath(ruta, \"crank_nick.csv\"), df)\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nusing DataFrames, CSV, Plots, Statistics\npyplot()\n\n# --- CARGAR DATOS DESDE EL CSV ---------------------------------------------\n#ruta = \"./Archivos\"\n#df = CSV.read(joinpath(ruta, \"biocalor_2d.csv\"), DataFrame)\n\n# --- OBTENER VALORES ÚNICOS Y ORDENADOS DE X, Y, TIME ----------------------\nx_vals = sort(unique(df.X))\ny_vals = sort(unique(df.Y))\ntimes = sort(unique(df.time))  # tiempos\n\nNx, Ny = length(x_vals), length(y_vals)\n\n# --- RECONSTRUIR MATRICES 2D DE THETA PARA CADA TIEMPO ---------------------\nsolutions = []\n\nfor t in times\n    dft = filter(:time => ==(t), df)\n\n    # Crear matriz vacía\n    Θ = fill(NaN, Nx, Ny)\n\n    # Llenar la matriz con los valores correspondientes\n    for row in eachrow(dft)\n        ix = findfirst(==(row.X), x_vals)\n        iy = findfirst(==(row.Y), y_vals)\n        Θ[ix, iy] = row.Theta\n    end\n\n    push!(solutions, Θ)\nend\n\n# --- DETERMINAR ESCALA GLOBAL DE COLORES -----------------------------------\nzmin = minimum([minimum(u) for u in solutions])\nzmax = maximum([maximum(u) for u in solutions])\n\n# --- GRAFICAR EN LAYOUT 3x2 ------------------------------------------------\np = plot(layout = (3, 2), size = (800, 900))\n\nfor (i, (t, Θ)) in enumerate(zip(times, solutions))\n    surface!(\n        p, y_vals, x_vals, Θ;  # transpuesta para que coincidan con x, y\n        camera = (45,30),\n        xlabel = \"Y\",\n        ylabel = \"X\",\n        zlabel = \"T   \",\n        title = \"t = $(t)\",\n        subplot = i,\n        c = :thermal,\n        clim = (zmin, zmax),\n        legend = false\n    )\nend\n\n# Eliminar ejes y contenido del subplot 6\nplot!(p[6], framestyle = :none, grid = false, xticks = false, yticks = false)\nclose(\"all\")\n\ndisplay(p)\n```\n\n::: {.cell-output .cell-output-display}\n![Resultados obtenidos mediante el método numérico de Crank Nickolson.](metodo-num_files/figure-pdf/fig-met-crank-nick-output-1.svg){#fig-met-crank-nick fig-pos='H'}\n:::\n:::\n\n\n",
    "supporting": [
      "metodo-num_files/figure-pdf"
    ],
    "filters": []
  }
}