{
  "hash": "6b19addb09e8a5ca405bc2ed831ddee7",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Comparación de resultados\nlang: es\nexecute: \n  freeze: auto\n---\n\n::: {style=\"text-align: justify\"}\n\n## Comparativa visual de las predicciones\nEsta sección presenta un análisis cualitativo de los resultados mediante la comparación directa entre las predicciones del modelo, las soluciones reportadas en el estudio de @medical_rep y las obtenidas mediante el método de Crank Nickolson. La visualización paralela permite evaluar:\n\n- Dominio espacial: Cuadrado unitario [0,1] × [0,1] con malla 26×26.\n- Escala de colores: Mapa térmico viridis (consistente en ambas columnas).\n\n### Modelo contra resultados de @medical_rep\n\n::: {#cell-fig-my_results .cell execution_count=1}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\nimport matplotlib.gridspec as gridspec\nimport pandas as pd\nimport numpy as np\n\n# Lista de tiempos\ntimes = [0.0, 0.25, 0.5, 0.75, 1.0]\n\n# Cargar el dataframe\ndf = pd.read_csv(r'data/model_DoN.csv')  \n\n# Crear figura con subplots 3D en 1 fila y 5 columnas\nfig, axes = plt.subplots(nrows=1, ncols=len(times), \n                        figsize=(22, 6),\n                        subplot_kw={'projection': '3d'})\n\n# Asumimos que el grid es regular\nnum_points = int(np.sqrt(df[df[\"time\"] == times[0]].shape[0]))\n\n# Lista para almacenar los objetos surface\nsurf_list = []\n\n# Reordenar para graficar\nfor i, (t_val, ax) in enumerate(zip(times, axes)):\n    # Filtrar por tiempo actual\n    df_t = df[df[\"time\"] == t_val]\n\n    # Obtener los valores de X, Y, Theta\n    X_vals = df_t[\"X\"].values.reshape((num_points, num_points))\n    Y_vals = df_t[\"Y\"].values.reshape((num_points, num_points))\n    Z_vals = df_t[\"Theta\"].values.reshape((num_points, num_points))\n\n    # Dibujar la superficie\n    surf = ax.plot_surface(\n        Y_vals, X_vals, Z_vals,\n        rstride=1, cstride=1,\n        cmap=\"YlGnBu\",\n        edgecolor=\"none\",\n        antialiased=True\n    )\n    surf_list.append(surf)\n\n    ax.set_title(f\"Time = {t_val:.2f} s\", pad=10)\n    ax.set_xlabel(\"Y\", labelpad=10)\n    ax.set_ylabel(\"X\", labelpad=10)\n    ax.set_zlabel(\"T [K]\", labelpad=10, rotation=90)\n\n\n# Añadir barra de color común\ncbar = fig.colorbar(surf_list[-1], ax=axes,\n                    shrink=0.9, aspect=90,\n                    pad=0.1, orientation='horizontal')\ncbar.set_label('Temperatura [K]')\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Predicciones de la red neuronal a distintos tiempos.](comparaciones_files/figure-html/fig-my_results-output-1.png){#fig-my_results width=1683 height=428}\n:::\n:::\n\n\n![Resultados reportados por @medical_rep en el caso 2D.](images/results_paper.png){#fig-results_fnn fig-align=\"center\" width=\"550\"}\n\n### Modelo contra método numérico\n\n::: {#cell-fig-met-num-vs-model .cell execution_count=2}\n``` {.python .cell-code}\ncrank_nick_data = pd.read_csv(r'data/crank_nick.csv')\nmodel_don_data = pd.read_csv(r'data/model_DoN.csv')\n\n# Determinar los límites comunes para el colorbar\nmin_temp = min(model_don_data['Theta'].min(),\n                crank_nick_data['Theta'].min())\nmax_temp = max(model_don_data['Theta'].max(), \n                crank_nick_data['Theta'].max())\n\n# Crear figura con subplots 3D en 2 filas y 5 columnas\nfig = plt.figure(figsize=(22, 12))\naxes = []\n\n# Crear los subplots\nfor i in range(2):  # 2 filas\n    for j in range(5):  # 5 columnas\n        axes.append(fig.add_subplot(2, 5, i*5 + j + 1, projection='3d'))\n\naxes = np.array(axes).reshape(2, 5)\n\n# Añadir títulos generales para cada fila\nfig.text(0.5, 0.92, \"Predicciones modelo DON\", \n        ha='center', va='center', fontsize=14,fontweight='bold')\nfig.text(0.5, 0.56, \"Predicciones método numérico\",\n        ha='center', va='center', fontsize=14, fontweight='bold')\n\n# Función para graficar un dataframe en una fila específica\ndef plot_dataframe(df, row, num_points, cmap=\"viridis\"):\n    surf_list = []\n    for col, t_val in enumerate(times):\n        ax = axes[row, col]\n        \n        # Filtrar por tiempo actual\n        df_t = df[df[\"time\"] == t_val]\n\n        # Obtener los valores de X, Y, Theta\n        X_vals = df_t[\"X\"].values.reshape((num_points, num_points))\n        Y_vals = df_t[\"Y\"].values.reshape((num_points, num_points))\n        Z_vals = df_t[\"Theta\"].values.reshape((num_points, num_points))\n\n        # Dibujar la superficie con límites comunes\n        surf = ax.plot_surface(\n            Y_vals, X_vals, Z_vals,\n            rstride=1, cstride=1,\n            cmap=cmap,\n            edgecolor=\"none\",\n            antialiased=True,\n            vmin=min_temp,\n            vmax=max_temp\n        )\n        surf_list.append(surf)\n\n        ax.set_title(f\"Time = {t_val:.2f} s\", pad=10)\n        ax.set_xlabel(\"Y\", labelpad=10)\n        ax.set_ylabel(\"X\", labelpad=10)\n        ax.set_zlabel(\"T [K]\", labelpad=10, rotation=90)\n    \n    return surf_list\n\n# Asumimos que el grid es regular para ambos dataframes\nnum_points = int(np.sqrt(\n        model_don_data[model_don_data[\"time\"] == times[0]].shape[0]))\n\n# Graficar el primer dataframe en la fila superior\nsurf_model_don = plot_dataframe(model_don_data, 0, num_points)\n\n# Graficar el segundo dataframe en la fila inferior\nsurf_crank_nick = plot_dataframe(crank_nick_data, 1, num_points)\n\n# Añadir barra de color común en la parte inferior\ncbar = fig.colorbar(surf_crank_nick[-1], ax=axes.ravel().tolist(),\n                    use_gridspec=True, orientation='horizontal',\n                    pad=0.05, aspect=90, shrink=0.9)\ncbar.set_label('Temperatura [K]', labelpad=10)\n\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Contraste de las predicciones entre el método de Crank Nikolson y el modelo para cada tiempo.](comparaciones_files/figure-html/fig-met-num-vs-model-output-1.png){#fig-met-num-vs-model width=1683 height=894}\n:::\n:::\n\n\n## Validación Cuantitativa frente al Método de Crank-Nicolson\nPara evaluar numéricamente la precisión del modelo DeepONet, se realizó una comparación sistemática con soluciones de referencia generadas mediante el método de Crank-Nicolson. Este enfoque proporciona una métrica objetiva de la exactitud del modelo, siendo complementado con una serie de gráficos que muestran el error absoluto para cada punto del dominio en los tiempos de interés.\n\n::: {#4ed7497a .cell execution_count=3}\n``` {.python .cell-code}\n# Función para calcular errores\ndef calculate_errors(true_data, pred_data, times):\n    results = []\n    \n    for time in times:\n        # Filtrar datos por tiempo\n        true_subset = true_data[true_data['time'] == time]\n        pred_subset = pred_data[pred_data['time'] == time]\n        \n        if len(true_subset) == 0 or len(pred_subset) == 0:\n            print(f\"Advertencia: No hay datos para tiempo t={time}\")\n            continue\n        \n        # Verificar que las dimensiones coincidan\n        if len(true_subset) != len(pred_subset):\n            print(f\"Advertencia:Num de puntos no coincide para t={time}\")\n            min_len = min(len(true_subset), len(pred_subset))\n            true_subset = true_subset.iloc[:min_len]\n            pred_subset = pred_subset.iloc[:min_len]\n        \n        # Calcular errores para Theta\n        theta_true = true_subset['Theta'].values\n        theta_pred = pred_subset['Theta'].values\n        \n        absolute_error = np.abs(theta_true - theta_pred)\n        l2_error = np.sqrt(np.sum((theta_true - theta_pred)**2))\n        \n        results.append({\n            'time': time,\n            'mean_absolute_error': np.mean(absolute_error),\n            'max_absolute_error': np.max(absolute_error),\n            'l2_error': l2_error\n        })\n    \n    return pd.DataFrame(results)\n\n# Calcular errores\nerror_results = calculate_errors(crank_nick_data, model_don_data, times)\n\n# Guardar resultados\nerror_results.to_csv(\"data/error_comparison.csv\", index=False)\n```\n:::\n\n\n::: {#tbl-errores .cell tbl-cap='Error del modelo DeepONet respecto a Crank-Nicolson.' execution_count=4}\n\n::: {.cell-output .cell-output-stdout}\n```\n|   Tiempo |   MAE |   MaxAE |   Error L2 |\n|---------:|------:|--------:|-----------:|\n|    0.000 | 0.011 |   0.058 |      0.404 |\n|    0.250 | 0.048 |   0.133 |      1.563 |\n|    0.500 | 0.032 |   0.058 |      0.934 |\n|    0.750 | 0.022 |   0.090 |      0.867 |\n|    1.000 | 0.094 |   0.254 |      3.089 |\n```\n:::\n:::\n\n\n### Gráficas de error absoluto\n\n::: {#cell-fig-abs-errors .cell execution_count=5}\n``` {.python .cell-code}\n# Calcular el error absoluto entre los dos dataframes\nerror_data = model_don_data.copy()\nerror_data['error'] = np.abs(\n                    crank_nick_data['Theta'] - model_don_data['Theta'])\n\n# Crear figura con 3 filas y 2 columnas\nfig, axes = plt.subplots(nrows=1, ncols=5, figsize=(22, 6))\naxes = axes.ravel()  # Convertir a array 1D para fácil acceso\n\n# Asumir que el grid es regular\nnum_points = int(np.sqrt(\n                    error_data[error_data[\"time\"] == times[0]].shape[0]\n                    ))\n\n# Configuración común para los mapas de calor\nplot_kwargs = {\n    'cmap': 'hot_r',\n    'shading': 'auto',\n    'vmin': error_data['error'].min(),\n    'vmax': error_data['error'].max()\n}\n# Lista para guardar los gráficos\nabs_errors_pc = []\n\n# Crear los subplots\nfor i, t_val in enumerate(times):\n    ax = axes[i]\n    \n    # Filtrar por tiempo actual\n    df_t = error_data[error_data[\"time\"] == t_val]\n    \n    # Obtener valores y reshape\n    X_vals = df_t[\"X\"].values.reshape((num_points, num_points))\n    Y_vals = df_t[\"Y\"].values.reshape((num_points, num_points))\n    error_vals = df_t[\"error\"].values.reshape((num_points, num_points))\n    \n    # Crear mapa de calor\n    pc = ax.pcolormesh(X_vals, Y_vals, error_vals, **plot_kwargs)\n    \n    # Configuración de ejes\n    ax.set_title(f\"Tiempo = {t_val:.2f} s\", pad=10)\n    ax.set_xlabel(\"X\")\n    ax.set_ylabel(\"Y\")\n    ax.set_aspect('equal')\n\n    abs_errors_pc.append(pc)\n\ncbar = fig.colorbar(abs_errors_pc[-1], ax=axes,\n                    use_gridspec=True, shrink=0.9,\n                    aspect=90, pad=0.1, orientation='horizontal')\ncbar.set_label('Error absoluto [K]')\n\n# Mostrar el gráfico\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Errores absolutos entre el método de Crank Nikolson y el modelo para cada tiempo.](comparaciones_files/figure-html/fig-abs-errors-output-1.png){#fig-abs-errors width=1710 height=428}\n:::\n:::\n\n\n:::\n\n",
    "supporting": [
      "comparaciones_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}